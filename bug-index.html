<!doctype html>
<html
  lang="en-us"
  q:render="ssr"
  q:route="/"
  q:container="paused"
  q:version="1.4.5"
  q:base="/build/"
  q:locale=""
  q:manifest-hash="c91snm"
>
  <!--qv q:id=0 q:key=tntn:Qb_0-->
  <!--qv q:id=1 q:key=TxCF:vp_3-->
  <!--qv q:s q:sref=1 q:key=-->
  <head q:head>
    <meta charset="utf-8" q:head />
    <link href="/manifest.json" rel="manifest" q:head />
    <!--qv q:id=2 q:key=0vph:vp_0-->
    <!--qv q:key=0D_0-->
    <title q:head>Welcome to Qwik</title>
    <link href="http://localhost:3000/" rel="canonical" q:id="3" q:head />
    <meta
      content="width=device-width, initial-scale=1.0"
      name="viewport"
      q:head
    />
    <link href="/favicon.svg" rel="icon" type="image/svg+xml" q:head />
    <meta name="description" content="Qwik site description" q:head />
    <!--/qv-->
    <!--/qv-->
    <style q:style="lcydw1-0" hidden>
      :root {
        view-transition-name: none;
      }
    </style>
  </head>
  <body lang="en">
    <!--qv q:id=4 q:key=e0ss:vp_1-->
    <!--qv q:key=zl_1-->
    <!--qv q:id=5 q:key=VKFl:zl_0-->
    <!--qv q:s q:sref=5 q:key=-->
    <!--qv q:id=6 q:key=B0lq:zl_0-->
    <!--qv q:key=i8_0-->
    <h1 on:qvisible="q-DZdUdpCg.js#_hW[0]" q:id="7">Hi ðŸ‘‹</h1>
    <p>Can't wait to see what you build with qwik!<br />Happy coding.</p>
    <!--/qv-->
    <!--/qv-->
    <!--/qv-->
    <!--/qv-->
    <script>
      (async (s, e) => {
        var o;
        if (!window._qcs && history.scrollRestoration === "manual") {
          window._qcs = !0;
          const n = (o = history.state) == null ? void 0 : o._qCityScroll;
          n && window.scrollTo(n.x, n.y);
          const t = document.currentScript;
          (await import(s))[e](t);
        }
      })("/build/q-fJkQnue_.js", "s_DyVc0YBIqQU");
    </script>
    <!--/qv-->
    <!--/qv-->
    <!--qv q:key=vp_2-->
    <script q:key="1Z_0">
      ((i, a, r, s) => {
        (r = (e) => {
          const t = document.querySelector("[q\\:base]");
          t &&
            a.active &&
            a.active.postMessage({
              type: "qprefetch",
              base: t.getAttribute("q:base"),
              ...e,
            });
        }),
          document.addEventListener("qprefetch", (e) => {
            const t = e.detail;
            a ? r(t) : i.push(t);
          }),
          navigator.serviceWorker
            .register("/service-worker.js")
            .then((e) => {
              (s = () => {
                (a = e),
                  i.forEach(r),
                  r({
                    bundles: i,
                  });
              }),
                e.installing
                  ? e.installing.addEventListener("statechange", (t) => {
                      t.target.state == "activated" && s();
                    })
                  : e.active && s();
            })
            .catch((e) => console.error(e));
      })([]);
    </script>
    <!--/qv-->
  </body>
  <!--/qv-->
  <!--/qv-->
  <!--/qv-->
  <script q:type="prefetch-bundles">
    document.dispatchEvent(
      new CustomEvent("qprefetch", {
        detail: {
          bundles: ["q-DZdUdpCg.js", "q-eVM5xaWG.js"],
        },
      })
    );
    document.dispatchEvent(
      new CustomEvent("qprefetch", {
        detail: {
          links: [location.pathname],
        },
      })
    );
  </script>
  <script type="qwik/json">
    {
      "refs": { "7": "1" },
      "ctx": {},
      "objs": ["\u0002q-DZdUdpCg.js#s_hs55Cc65pvA", "\u00031 0 0 #6"],
      "subs": []
    }
  </script>
  <script id="qwikloader">
    ((e, t) => {
      const n = "__q_context__",
        s = window,
        o = new Set(),
        i = (t) => e.querySelectorAll(t),
        a = (e, t, n = t.type) => {
          i("[on" + e + "\\:" + n + "]").forEach((s) => f(s, e, t, n));
        },
        r = (e, t) => e.getAttribute(t),
        l = (t) => {
          if (void 0 === t._qwikjson_) {
            let n = (t === e.documentElement ? e.body : t).lastElementChild;
            for (; n; ) {
              if ("SCRIPT" === n.tagName && "qwik/json" === r(n, "type")) {
                t._qwikjson_ = JSON.parse(
                  n.textContent.replace(/\\x3C(\/?script)/gi, "<$1")
                );
                break;
              }
              n = n.previousElementSibling;
            }
          }
        },
        c = (e, t) =>
          new CustomEvent(e, {
            detail: t,
          }),
        f = async (t, s, o, i = o.type) => {
          const a = "on" + s + ":" + i;
          t.hasAttribute("preventdefault:" + i) && o.preventDefault();
          const c = t._qc_,
            f = null == c ? void 0 : c.li.filter((e) => e[0] === a);
          if (f && f.length > 0) {
            for (const e of f)
              await e[1].getFn([t, o], () => t.isConnected)(o, t);
            return;
          }
          const b = r(t, a);
          if (b) {
            const s = t.closest("[q\\:container]"),
              i = new URL(r(s, "q:base"), e.baseURI);
            for (const a of b.split("\n")) {
              const r = new URL(a, i),
                c = r.hash.replace(/^#?([^?[|]*).*$/, "$1") || "default",
                f = performance.now();
              let b;
              const d = a.startsWith("#"); // d = false
              if (d) b = (s.qFuncs || [])[Number.parseInt(c)];
              else {
                const e = import(/* @vite-ignore */ r.href.split("#")[0]);
                l(s), (b = (await e)[c]);
              }
              const p = e[n];
              if (t.isConnected)
                try {
                  (e[n] = [t, o, r]),
                    d ||
                      u("qsymbol", {
                        symbol: c,
                        element: t,
                        reqTime: f,
                      }),
                    await b(o, t);
                } finally {
                  e[n] = p;
                }
            }
          }
        },
        u = (t, n) => {
          e.dispatchEvent(c(t, n));
        },
        b = (e) => e.replace(/([A-Z])/g, (e) => "-" + e.toLowerCase()),
        d = async (e) => {
          let t = b(e.type),
            n = e.target;
          for (a("-document", e, t); n && n.getAttribute; )
            await f(n, "", e, t),
              (n = e.bubbles && !0 !== e.cancelBubble ? n.parentElement : null);
        },
        p = (e) => {
          a("-window", e, b(e.type));
        },
        q = () => {
          var n;
          const a = e.readyState;
          if (
            !t &&
            ("interactive" == a || "complete" == a) &&
            ((t = 1),
            u("qinit"),
            (null != (n = s.requestIdleCallback) ? n : s.setTimeout).bind(s)(
              () => u("qidle")
            ),
            o.has("qvisible"))
          ) {
            const e = i("[on\\:qvisible]"),
              t = new IntersectionObserver((e) => {
                for (const n of e)
                  n.isIntersecting &&
                    (t.unobserve(n.target), f(n.target, "", c("qvisible", n)));
              });
            e.forEach((e) => t.observe(e));
          }
        },
        w = (e, t, n, s = !1) =>
          e.addEventListener(t, n, {
            capture: s,
            passive: !1,
          }),
        v = (t) => {
          for (const n of t) o.has(n) || (w(e, n, d, !0), w(s, n, p), o.add(n));
        };
      if (!e.qR) {
        const t = s.qwikevents;
        Array.isArray(t) && v(t),
          (s.qwikevents = {
            push: (...e) => v(e),
          }),
          w(e, "readystatechange", q),
          q();
      }
    })(document);
  </script>
  <script>
    window.qwikevents.push("qvisible");
  </script>
</html>
